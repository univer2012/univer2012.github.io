
 <!DOCTYPE HTML>
<html lang="zh-cn">
<head>
  <meta charset="UTF-8">
  
    <title>读《Objective-C Runtime 运行时之三：方法与消息》摘录 | SengolnHuang&#39;s blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="黄胜军">
    

    
    <meta name="description" content="本文出处：Objective-C Runtime 运行时之三：方法与消息原文出处： 南峰子的技术博客  前面我们讨论了Runtime中对类和对象的处理，及对成员变量与属性的处理。这一章，我们就要开始讨论Runtime中最有意思的一部分：消息处理机制。我们将详细讨论消息的发送及消息的转发。不过在讨论消息之前，我们先来了解一下与方法相关的一些内容。 基础数据类型一、SELSEL又叫选择器，是表示一个方">
<meta name="keywords">
<meta property="og:type" content="article">
<meta property="og:title" content="读《Objective-C Runtime 运行时之三：方法与消息》摘录">
<meta property="og:url" content="https://univer2012.github.io/2017/05/11/8Objective-C-Runtime-Three/index.html">
<meta property="og:site_name" content="SengolnHuang's blog">
<meta property="og:description" content="本文出处：Objective-C Runtime 运行时之三：方法与消息原文出处： 南峰子的技术博客  前面我们讨论了Runtime中对类和对象的处理，及对成员变量与属性的处理。这一章，我们就要开始讨论Runtime中最有意思的一部分：消息处理机制。我们将详细讨论消息的发送及消息的转发。不过在讨论消息之前，我们先来了解一下与方法相关的一些内容。 基础数据类型一、SELSEL又叫选择器，是表示一个方">
<meta property="og:image" content="https://univer2012.github.io/2017/05/11/8Objective-C-Runtime-Three/pic1.png">
<meta property="og:image" content="https://univer2012.github.io/2017/05/11/8Objective-C-Runtime-Three/pic2.png">
<meta property="og:updated_time" content="2017-05-15T06:42:25.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="读《Objective-C Runtime 运行时之三：方法与消息》摘录">
<meta name="twitter:description" content="本文出处：Objective-C Runtime 运行时之三：方法与消息原文出处： 南峰子的技术博客  前面我们讨论了Runtime中对类和对象的处理，及对成员变量与属性的处理。这一章，我们就要开始讨论Runtime中最有意思的一部分：消息处理机制。我们将详细讨论消息的发送及消息的转发。不过在讨论消息之前，我们先来了解一下与方法相关的一些内容。 基础数据类型一、SELSEL又叫选择器，是表示一个方">
<meta name="twitter:image" content="https://univer2012.github.io/2017/05/11/8Objective-C-Runtime-Three/pic1.png">

    
    <link rel="alternative" href="/atom.xml" title="SengolnHuang&#39;s blog" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.png" alt="SengolnHuang&#39;s blog" title="SengolnHuang&#39;s blog"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="SengolnHuang&#39;s blog">SengolnHuang&#39;s blog</a></h1>
				<h2 class="blog-motto">关注技术，分享生活</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="Menu">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">主页</a></li>
					
						<li><a href="/archives">归档</a></li>
					
						<li><a href="/about">关于</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="Search" />
						<input type="hidden" name="q" value="site:univer2012.github.io">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
  
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/05/11/8Objective-C-Runtime-Three/" title="读《Objective-C Runtime 运行时之三：方法与消息》摘录" itemprop="url">读《Objective-C Runtime 运行时之三：方法与消息》摘录</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="黄胜军" target="_blank" itemprop="author">黄胜军</a>
		
  <p class="article-time">
    <time datetime="2017-05-11T01:44:10.000Z" itemprop="datePublished"> Published 2017-05-11</time>
    
  </p>
</header>
	<div class="article-content">
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">Contents</strong>
		
			<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#基础数据类型"><span class="toc-number">1.</span> <span class="toc-text">基础数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#一、SEL"><span class="toc-number">1.1.</span> <span class="toc-text">一、SEL</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二、IMP"><span class="toc-number">1.2.</span> <span class="toc-text">二、IMP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三、Method"><span class="toc-number">1.3.</span> <span class="toc-text">三、Method</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#四、objc-method-description"><span class="toc-number">1.4.</span> <span class="toc-text">四、objc_method_description</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#方法相关操作函数"><span class="toc-number">2.</span> <span class="toc-text">方法相关操作函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#一、方法"><span class="toc-number">2.1.</span> <span class="toc-text">一、方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二、方法选择器"><span class="toc-number">2.2.</span> <span class="toc-text">二、方法选择器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三、方法调用流程"><span class="toc-number">2.3.</span> <span class="toc-text">三、方法调用流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#四、隐藏参数"><span class="toc-number">2.4.</span> <span class="toc-text">四、隐藏参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#五、获取方法地址"><span class="toc-number">2.5.</span> <span class="toc-text">五、获取方法地址</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#六、消息转发"><span class="toc-number">2.6.</span> <span class="toc-text">六、消息转发</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-动态方法解析"><span class="toc-number">2.6.0.1.</span> <span class="toc-text">1.动态方法解析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-备用接收者"><span class="toc-number">2.6.0.2.</span> <span class="toc-text">2.备用接收者</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-完整消息转发"><span class="toc-number">2.6.0.3.</span> <span class="toc-text">3.完整消息转发</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#七、消息转发与多重继承"><span class="toc-number">2.7.</span> <span class="toc-text">七、消息转发与多重继承</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#小结"><span class="toc-number">3.</span> <span class="toc-text">小结</span></a></li></ol>
		
		</div>
		
		<p>本文出处：<a href="http://blog.jobbole.com/79574/?utm_source=blog.jobbole.com&amp;utm_medium=relatedPosts" target="_blank" rel="external">Objective-C Runtime 运行时之三：方法与消息</a><br>原文出处： 南峰子的技术博客 </p>
<p>前面我们讨论了Runtime中对类和对象的处理，及对成员变量与属性的处理。这一章，我们就要开始讨论Runtime中最有意思的一部分：消息处理机制。我们将详细讨论消息的发送及消息的转发。不过在讨论消息之前，我们先来了解一下与方法相关的一些内容。</p>
<h1 id="基础数据类型"><a href="#基础数据类型" class="headerlink" title="基础数据类型"></a>基础数据类型</h1><h2 id="一、SEL"><a href="#一、SEL" class="headerlink" title="一、SEL"></a>一、SEL</h2><p>SEL又叫选择器，是表示一个方法的selector的指针，其定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">typedef struct objc_selector *SEL;</div></pre></td></tr></table></figure>
<p>objc_selector结构体的详细定义没有在<objc runtime.h="">头文件中找到。方法的selector用于表示运行时方法的名字。<strong>Objective-C在编译时，会依据每一个方法的名字、参数序列，生成一个唯一的整型标识(Int类型的地址)，这个标识就是SEL。</strong>如下代码所示：</objc></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">-(void)p_testSelector &#123;</div><div class="line">    SEL sel1 = @selector(method1);</div><div class="line">    NSLog(@&quot;sel: %p&quot;,sel1);</div><div class="line">&#125;</div><div class="line">-(void)method1 &#123;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的输出为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">2017-05-11 11:35:47.265 ObjectiveCDemo160728[237:1462795] sel: 0x107156ebc</div></pre></td></tr></table></figure>
<p><strong>两个类之间，不管它们是父类与子类的关系，还是之间没有这种关系，只要方法名相同，那么方法的SEL就是一样的。每一个方法都对应着一个SEL。所以在Objective-C同一个类(及类的继承体系)中，不能存在2个同名的方法，即使参数类型不同也不行。相同的方法只能对应一个SEL。</strong>这也就导致Objective-C在处理相同方法名且参数个数相同但类型不同的方法方面的能力很差。如在某个类中定义以下两个方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (void)setWidth:(int)width;</div><div class="line">- (void)setWidth:(double)width;</div></pre></td></tr></table></figure>
<blockquote>
<p>报错：<br><img src="/2017/05/11/8Objective-C-Runtime-Three/pic1.png" alt=""><br>这样的定义被认为是一种编译错误，所以我们不能像C++, C#那样。而是需要像下面这样来声明：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">-(void)setWidthIntValue:(int)width;</div><div class="line">-(void)setWidthDoubleValue:(double)width;</div></pre></td></tr></table></figure>
<p>当然，<strong>不同的类可以拥有相同的selector，这个没有问题。不同类的实例对象执行相同的selector时，会在各自的方法列表中去根据selector去寻找自己对应的IMP。</strong></p>
<p>工程中的所有的SEL组成一个Set集合，Set的特点就是唯一，因此SEL是唯一的。因此，如果我们想到这个方法集合中查找某个方法时，只需要去找到这个方法对应的SEL就行了，<strong>SEL实际上就是根据方法名hash化了的一个字符串，而对于字符串的比较仅仅需要比较他们的地址就可以了</strong>，可以说速度上无语伦比！！但是，有一个问题，就是数量增多会增大hash冲突而导致的性能下降（或是没有冲突，因为也可能用的是perfect hash）。但是不管使用什么样的方法加速，如果能够将总量减少（多个方法可能对应同一个SEL），那将是最犀利的方法。那么，我们就不难理解，为什么SEL仅仅是函数名了。</p>
<p><strong>本质上，SEL只是一个指向方法的指针（准确的说，只是一个根据方法名hash化了的KEY值，能唯一代表一个方法），它的存在只是为了加快方法的查询速度。</strong>这个查找过程我们将在下面讨论。</p>
<p>我们可以在运行时添加新的selector，也可以在运行时获取已存在的selector，我们可以通过下面三种方法来获取SEL:</p>
<ol>
<li>sel_registerName函数</li>
<li>Objective-C编译器提供的@selector()</li>
<li>NSSelectorFromString()方法</li>
</ol>
<h2 id="二、IMP"><a href="#二、IMP" class="headerlink" title="二、IMP"></a>二、IMP</h2><p><strong>IMP实际上是一个函数指针，指向方法实现的首地址。</strong>其定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">id (*IMP)(id, SEL, ...)</div></pre></td></tr></table></figure>
<p>这个函数使用当前CPU架构实现的标准的C调用约定。<em>第一个参数是指向self的指针(如果是实例方法，则是类实例的内存地址；如果是类方法，则是指向元类的指针)，第二个参数是方法选择器(selector)，接下来是方法的实际参数列表。</em></p>
<p>前面介绍过的SEL就是为了查找方法的最终实现IMP的。由于每个方法对应唯一的SEL，因此我们可以通过SEL方便快速准确地获得它所对应的IMP，查找过程将在下面讨论。取得IMP后，我们就获得了执行这个方法代码的入口点，此时，我们就可以像调用普通的C语言函数一样来使用这个函数指针了。</p>
<p><strong>通过取得IMP，我们可以跳过Runtime的消息传递机制，直接执行IMP指向的函数实现，这样省去了Runtime消息传递过程中所做的一系列查找操作，会比直接向对象发送消息高效一些。</strong></p>
<h2 id="三、Method"><a href="#三、Method" class="headerlink" title="三、Method"></a>三、Method</h2><p>介绍完SEL和IMP，我们就可以来讲讲Method了。Method用于表示类定义中的方法，则定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">typedef struct objc_method *Method;</div><div class="line"> </div><div class="line">struct objc_method &#123;</div><div class="line">    SEL method_name                 OBJC2_UNAVAILABLE;  // 方法名</div><div class="line">    char *method_types                  OBJC2_UNAVAILABLE;</div><div class="line">    IMP method_imp                      OBJC2_UNAVAILABLE;  // 方法实现</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以看到该结构体中包含一个SEL和IMP，<strong>实际上相当于在SEL和IMP之间作了一个映射。有了SEL，我们便可以找到对应的IMP，从而调用方法的实现代码。</strong>具体操作流程我们将在下面讨论。</p>
<h2 id="四、objc-method-description"><a href="#四、objc-method-description" class="headerlink" title="四、objc_method_description"></a>四、objc_method_description</h2><p>objc_method_description定义了一个Objective-C方法，其定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">struct objc_method_description &#123; </div><div class="line">   SEL name; char *types; </div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h1 id="方法相关操作函数"><a href="#方法相关操作函数" class="headerlink" title="方法相关操作函数"></a>方法相关操作函数</h1><p>Runtime提供了一系列的方法来处理与方法相关的操作。包括方法本身及SEL。本节我们介绍一下这些函数。</p>
<h2 id="一、方法"><a href="#一、方法" class="headerlink" title="一、方法"></a>一、方法</h2><p>方法操作相关函数包括下以：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">// 调用指定方法的实现</div><div class="line">id method_invoke ( id receiver, Method m, ... );</div><div class="line"> </div><div class="line">// 调用返回一个数据结构的方法的实现</div><div class="line">void method_invoke_stret ( id receiver, Method m, ... );</div><div class="line"> </div><div class="line">// 获取方法名</div><div class="line">SEL method_getName ( Method m );</div><div class="line"> </div><div class="line">// 返回方法的实现</div><div class="line">IMP method_getImplementation ( Method m );</div><div class="line"> </div><div class="line">// 获取描述方法参数和返回值类型的字符串</div><div class="line">const char * method_getTypeEncoding ( Method m );</div><div class="line"> </div><div class="line">// 获取方法的返回值类型的字符串</div><div class="line">char * method_copyReturnType ( Method m );</div><div class="line"> </div><div class="line">// 获取方法的指定位置参数的类型字符串</div><div class="line">char * method_copyArgumentType ( Method m, unsigned int index );</div><div class="line"> </div><div class="line">// 通过引用返回方法的返回值类型字符串</div><div class="line">void method_getReturnType ( Method m, char *dst, size_t dst_len );</div><div class="line"> </div><div class="line">// 返回方法的参数的个数</div><div class="line">unsigned int method_getNumberOfArguments ( Method m );</div><div class="line"> </div><div class="line">// 通过引用返回方法指定位置参数的类型字符串</div><div class="line">void method_getArgumentType ( Method m, unsigned int index, char *dst, size_t dst_len );</div><div class="line"> </div><div class="line">// 返回指定方法的方法描述结构体</div><div class="line">struct objc_method_description * method_getDescription ( Method m );</div><div class="line"> </div><div class="line">// 设置方法的实现</div><div class="line">IMP method_setImplementation ( Method m, IMP imp );</div><div class="line"> </div><div class="line">// 交换两个方法的实现</div><div class="line">void method_exchangeImplementations ( Method m1, Method m2 );</div></pre></td></tr></table></figure>
<ul>
<li><code>method_invoke</code>函数，返回的是实际实现的返回值。参数receiver不能为空。这个方法的效率会比<code>method_getImplementation</code>和<code>method_getName</code>更快。</li>
<li><code>method_getName</code>函数，返回的是一个SEL。如果想获取方法名的C字符串，可以使用<code>sel_getName(method_getName(method))</code>。</li>
<li><code>method_getReturnType</code>函数，类型字符串会被拷贝到dst中。</li>
<li><code>method_setImplementation</code>函数，注意该函数返回值是方法之前的实现。</li>
</ul>
<h2 id="二、方法选择器"><a href="#二、方法选择器" class="headerlink" title="二、方法选择器"></a>二、方法选择器</h2><p>选择器相关的操作函数包括：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// 返回给定选择器指定的方法的名称</div><div class="line">const char * sel_getName ( SEL sel );</div><div class="line"> </div><div class="line">// 在Objective-C Runtime系统中注册一个方法，将方法名映射到一个选择器，并返回这个选择器</div><div class="line">SEL sel_registerName ( const char *str );</div><div class="line"> </div><div class="line">// 在Objective-C Runtime系统中注册一个方法</div><div class="line">SEL sel_getUid ( const char *str );</div><div class="line"> </div><div class="line">// 比较两个选择器</div><div class="line">BOOL sel_isEqual ( SEL lhs, SEL rhs );</div></pre></td></tr></table></figure>
<ul>
<li><code>sel_registerName</code>函数：在我们将一个方法添加到类定义时，我们必须在Objective-C Runtime系统中注册一个方法名以获取方法的选择器。</li>
</ul>
<h2 id="三、方法调用流程"><a href="#三、方法调用流程" class="headerlink" title="三、方法调用流程"></a>三、方法调用流程</h2><p><strong>在Objective-C中，消息直到运行时才绑定到方法实现上。</strong>编译器会将消息表达式[receiver message]转化为一个消息函数的调用，即<code>objc_msgSend</code>。这个函数将消息接收者和方法名作为其基础参数，如以下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">objc_msgSend(receiver, selector)</div></pre></td></tr></table></figure>
<p>如果消息中还有其它参数，则该方法的形式如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">objc_msgSend(receiver, selector, arg1, arg2, ...)</div></pre></td></tr></table></figure>
<p>这个函数完成了动态绑定的所有事情：</p>
<ol>
<li>首先它找到selector对应的方法实现。因为同一个方法可能在不同的类中有不同的实现，所以我们需要依赖于接收者的类来找到它确切的实现。</li>
<li>它调用方法实现，并将接收者对象及方法的所有参数传给它。</li>
<li>最后，它将实现返回的值作为它自己的返回值。</li>
</ol>
<p>消息的关键在于我们<a href="https://univer2012.github.io/2017/05/06/%E8%BF%90%E8%A1%8C%E6%97%B6%E4%B9%8B%E4%B8%80%EF%BC%9A%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%E3%80%8B%E7%AC%94%E8%AE%B0/#Class">前面章节</a>讨论过的结构体<code>objc_class</code>，这个结构体有两个字段是我们在分发消息的关注的：</p>
<ol>
<li>指向父类的指针<code>Class super_class</code></li>
<li>一个类的方法分发表，即<code>struct objc_method_list **methodLists</code>。</li>
</ol>
<p>当我们创建一个新对象时，先为其分配内存，并初始化其成员变量。其中isa指针也会被初始化，让对象可以访问类及类的继承体系。</p>
<p>下图演示了这样一个消息的基本框架：<br><img src="/2017/05/11/8Objective-C-Runtime-Three/pic2.png" alt=""></p>
<p><strong>当消息发送给一个对象时，objc_msgSend通过对象的isa指针获取到类的结构体，然后在方法分发表里面查找方法的selector。如果没有找到selector，则通过objc_msgSend结构体中的指向父类的指针找到其父类，并在父类的分发表里面查找方法的selector。依此，会一直沿着类的继承体系到达NSObject类。一旦定位到selector，函数会就获取到了实现的入口点，并传入相应的参数来执行方法的具体实现。如果最后没有定位到selector，则会走消息转发流程，这个我们在后面讨论。</strong></p>
<p>为了加速消息的处理，运行时系统缓存使用过的selector及对应的方法的地址。这点我们在<a href="http://southpeak.github.io/2014/10/25/objective-c-runtime-1/" target="_blank" rel="external">前面</a>讨论过，不再重复。</p>
<h2 id="四、隐藏参数"><a href="#四、隐藏参数" class="headerlink" title="四、隐藏参数"></a>四、隐藏参数</h2><p><code>objc_msgSend</code>有两个隐藏参数：</p>
<ol>
<li>消息接收对象</li>
<li>方法的selector</li>
</ol>
<p>这两个参数为方法的实现提供了调用者的信息。<em>之所以说是隐藏的，是因为它们在定义方法的源代码中没有声明。它们是在编译期被插入实现代码的。</em></p>
<p>虽然这些参数没有显示声明，但在代码中仍然可以引用它们。我们可以使用self来引用接收者对象，使用_cmd来引用选择器。如下代码所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">//这段代码没看懂</div><div class="line">- strange</div><div class="line">&#123;</div><div class="line">    id  target = getTheReceiver();</div><div class="line">    SEL method = getTheMethod();</div><div class="line"> </div><div class="line">    if ( target == self || method == _cmd )</div><div class="line">        return nil;</div><div class="line">    return [target performSelector:method];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当然，这两个参数我们用得比较多的是self，_cmd在实际中用得比较少。</p>
<h2 id="五、获取方法地址"><a href="#五、获取方法地址" class="headerlink" title="五、获取方法地址"></a>五、获取方法地址</h2><p>Runtime中方法的动态绑定让我们写代码时更具灵活性，如我们可以把消息转发给我们想要的对象，或者随意交换一个方法的实现等。不过灵活性的提升也带来了性能上的一些损耗。毕竟我们需要去查找方法的实现，而不像函数调用来得那么直接。当然，方法的缓存一定程度上解决了这一问题。</p>
<p>我们上面提到过，<strong>如果想要避开这种动态绑定方式，我们可以获取方法实现的地址，然后像调用函数一样来直接调用它。特别是当我们需要在一个循环内频繁地调用一个特定的方法时，通过这种方式可以提高程序的性能。</strong></p>
<p>NSObject类提供了<code>methodForSelector:</code>方法，让我们可以获取到方法的指针，然后通过这个指针来调用实现代码。我们需要将<code>methodForSelector:</code>返回的指针转换为合适的函数类型，函数参数和返回值都需要匹配上。</p>
<p>我们通过以下代码来看看<code>methodForSelector:</code>的使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">-(void)p_testMethodForSelector &#123;</div><div class="line">    NSArray *targetList = [NSArray array];</div><div class="line">    void (*setter)(id, SEL, BOOL);</div><div class="line">    int i;</div><div class="line">    NSObject *target = [NSObject new];</div><div class="line">    setter = (void (*)(id, SEL, BOOL))[target methodForSelector:@selector(setFilled:)];</div><div class="line">    for (i = 0; i &lt; 100; i++) &#123;</div><div class="line">        setter(targetList[i], @selector(setFilled:), YES);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里需要注意的就是函数指针的前两个参数必须是id和SEL。</p>
<p>当然这种方式只适合于在类似于for循环这种情况下频繁调用同一方法，以提高性能的情况。另外，<strong><code>methodForSelector:</code>是由Cocoa运行时提供的；它不是Objective-C语言的特性。</strong></p>
<h2 id="六、消息转发"><a href="#六、消息转发" class="headerlink" title="六、消息转发"></a>六、消息转发</h2><p>当一个对象能接收一个消息时，就会走正常的方法调用流程。但如果一个对象无法接收指定消息时，又会发生什么事呢？<strong>默认情况下，如果是以[object message]的方式调用方法，如果object无法响应message消息时，编译器会报错。但如果是以perform…的形式来调用，则需要等到运行时才能确定object是否能接收message消息。如果不能，则程序崩溃。</strong></p>
<p>通常，当我们不能确定一个对象是否能接收某个消息时，会先调用<code>respondsToSelector:</code>来判断一下。如下代码所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if ([self respondsToSelector:@selector(method)]) &#123;</div><div class="line">   [self performSelector:@selector(method)];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>不过，我们这边想讨论下不使用<code>respondsToSelector:</code>判断的情况。这才是我们这一节的重点。</p>
<p>当一个对象无法接收某一消息时，就会启动所谓<strong>“消息转发(message forwarding)”机制</strong>，通过这一机制，我们可以告诉对象如何处理未知的消息。默认情况下，对象接收到未知的消息，会导致程序崩溃，通过控制台，我们可以看到以下异常信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//[self performSelector:@selector(method)];</div><div class="line"></div><div class="line">2017-05-11 19:34:37.687 ObjectiveCDemo160728[32056:1964591] -[SGH0511Runtime3ViewController method]: unrecognized selector sent to instance 0x7ff351426b40</div><div class="line">2017-05-11 19:35:40.766 ObjectiveCDemo160728[32056:1964591] *** Terminating app due to uncaught exception &apos;NSInvalidArgumentException&apos;, reason: &apos;-[SGH0511Runtime3ViewController method]: unrecognized selector sent to instance 0x7ff351426b40&apos;</div></pre></td></tr></table></figure>
<p><strong>这段异常信息实际上是由NSObject的”doesNotRecognizeSelector”方法抛出的。不过，我们可以采取一些措施，让我们的程序执行特定的逻辑，而避免程序的崩溃。</strong></p>
<p>消息转发机制基本上分为三个步骤：</p>
<ol>
<li>动态方法解析</li>
<li>备用接收者</li>
<li>完整转发</li>
</ol>
<p>下面我们详细讨论一下这三个步骤。</p>
<h4 id="1-动态方法解析"><a href="#1-动态方法解析" class="headerlink" title="1.动态方法解析"></a>1.动态方法解析</h4><p>对象在接收到未知的消息时，首先会调用所属类的类方法<code>+resolveInstanceMethod:</code>(实例方法)或者<code>+resolveClassMethod:</code>(类方法)。在这个方法中，我们有机会为该未知消息新增一个”处理方法”。不过使用该方法的前提是我们已经实现了该”处理方法”，只需要在运行时通过<code>class_addMethod</code>函数动态添加到类里面就可以了。如下代码所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">- (void)viewDidLoad &#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    [self performSelector:@selector(method1)];</div><div class="line">&#125;</div><div class="line"></div><div class="line">void functionForMethod1(id self, SEL _cmd) &#123;</div><div class="line">    NSLog(@&quot;%@, %p&quot;,self,_cmd);</div><div class="line">&#125;</div><div class="line"></div><div class="line">+(BOOL)resolveInstanceMethod:(SEL)sel &#123;</div><div class="line">    NSString *selectorString = NSStringFromSelector(sel);</div><div class="line">    if ([selectorString isEqualToString:@&quot;method1&quot;]) &#123;</div><div class="line">        class_addMethod(self.class, @selector(method1), (IMP)functionForMethod1, &quot;@:&quot;);</div><div class="line">        return YES;</div><div class="line">    &#125;</div><div class="line">    return [super resolveInstanceMethod:sel];</div><div class="line">&#125;</div><div class="line">//-(void)method1 &#123;</div><div class="line">//    </div><div class="line">//&#125;</div></pre></td></tr></table></figure>
<p>运行后打印结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">2017-05-12 13:38:08.698 ObjectiveCDemo160728[65818:2284007] &lt;SGH0511Runtime3ViewController: 0x7fa6ddc3bb00&gt;, 0x10618fdac</div></pre></td></tr></table></figure>
<p>不过这种方案更多的是为了实现@dynamic属性。</p>
<h4 id="2-备用接收者"><a href="#2-备用接收者" class="headerlink" title="2.备用接收者"></a>2.备用接收者</h4><p>如果在上一步无法处理消息，则Runtime会继续调以下方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (id)forwardingTargetForSelector:(SEL)aSelector</div></pre></td></tr></table></figure>
<p><strong>如果一个对象实现了这个方法，并返回一个非nil的结果，则这个对象会作为消息的新接收者，且消息会被分发到这个对象。当然这个对象不能是self自身，否则就是出现无限循环。当然，如果我们没有指定相应的对象来处理aSelector，则应该调用父类的实现来返回结果。</strong></p>
<p>使用这个方法通常是在对象内部，可能还有一系列其它对象能处理该消息，我们便可借这些对象来处理消息并返回，这样在对象外部看来，还是由该对象亲自处理了这一消息。如下代码所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line">//-----------------------------------</div><div class="line">//SGH0511RuntimeMethod.h</div><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line"></div><div class="line">@interface SGH0511RuntimeMethod : NSObject</div><div class="line"></div><div class="line">+(instancetype)object;</div><div class="line"></div><div class="line">-(void)test;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">//-----------------------------------</div><div class="line">//SGH0511RuntimeMethod.m</div><div class="line"></div><div class="line">#import &quot;SGH0511RuntimeMethod.h&quot;</div><div class="line"></div><div class="line">@interface SGH0511RuntimeMethodHelper:NSObject</div><div class="line"></div><div class="line">-(void)method2;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation SGH0511RuntimeMethodHelper</div><div class="line"></div><div class="line">-(void)method2 &#123;</div><div class="line">    NSLog(@&quot;%@, %p&quot;, self, _cmd);</div><div class="line">&#125;</div><div class="line">@end</div><div class="line"></div><div class="line">#pragma mark -</div><div class="line"></div><div class="line">@implementation SGH0511RuntimeMethod &#123;</div><div class="line">    SGH0511RuntimeMethodHelper *_helper;</div><div class="line">&#125;</div><div class="line">+(instancetype)object &#123;</div><div class="line">    return [[self alloc]init];</div><div class="line">&#125;</div><div class="line">- (instancetype)init</div><div class="line">&#123;</div><div class="line">    self = [super init];</div><div class="line">    if (self) &#123;</div><div class="line">        _helper = [[SGH0511RuntimeMethodHelper alloc]init];</div><div class="line">    &#125;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line"></div><div class="line">-(void)test &#123;</div><div class="line">    [self performSelector:@selector(method2)];</div><div class="line">&#125;</div><div class="line"></div><div class="line">-(id)forwardingTargetForSelector:(SEL)aSelector &#123;</div><div class="line">    NSLog(@&quot;forwardingTargetForSelector&quot;);</div><div class="line">    NSString *selectorString = NSStringFromSelector(aSelector);</div><div class="line">    //将消息转发给_helper来处理</div><div class="line">    if ([selectorString isEqualToString:@&quot;method2&quot;]) &#123;</div><div class="line">        return _helper;</div><div class="line">    &#125;</div><div class="line">    return [super forwardingTargetForSelector:aSelector];</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">//-----------------------------------</div><div class="line">//SGH0511Runtime3ViewController.m</div><div class="line"></div><div class="line">#import &quot;SGH0511Runtime3ViewController.h&quot;</div><div class="line">#import &quot;SGH0511RuntimeMethod.h&quot;</div><div class="line"></div><div class="line">@implementation SGH0511Runtime3ViewController</div><div class="line"></div><div class="line">- (void)viewDidLoad &#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    [[SGH0511RuntimeMethod object]test];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>这一步适合于我们只想将消息转发到另一个能处理该消息的对象上</strong>。但这一步无法对消息进行处理，如操作消息的参数和返回值</p>
<h4 id="3-完整消息转发"><a href="#3-完整消息转发" class="headerlink" title="3.完整消息转发"></a>3.完整消息转发</h4><p>如果在上一步还不能处理未知消息，则<em>唯一能做的就是启用完整的消息转发机制了</em>。此时会调用以下方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (void)forwardInvocation:(NSInvocation *)anInvocation</div></pre></td></tr></table></figure>
<p><strong>运行时系统会在这一步给消息接收者最后一次机会将消息转发给其它对象。对象会创建一个表示消息的<code>NSInvocation</code>对象，把与尚未处理的消息有关的全部细节都封装在anInvocation中，包括selector，目标(target)和参数。我们可以在<code>forwardInvocation</code>方法中选择将消息转发给其它对象。</strong></p>
<p>forwardInvocation:方法的实现有两个任务：</p>
<ol>
<li>定位可以响应封装在anInvocation中的消息的对象。这个对象不需要能处理所有未知消息。</li>
<li>使用anInvocation作为参数，将消息发送到选中的对象。anInvocation将会保留调用结果，运行时系统会提取这一结果并将其发送到消息的原始发送者。</li>
</ol>
<p>不过，在这个方法中我们可以实现一些更复杂的功能，我们可以对消息的内容进行修改，比如追回一个参数等，然后再去触发消息。另外，若发现某个消息不应由本类处理，则应调用父类的同名方法，以便继承体系中的每个类都有机会处理此调用请求。</p>
<p>还有一个很重要的问题，我们必须重写以下方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</div></pre></td></tr></table></figure>
<p><strong>消息转发机制使用从这个方法中获取的信息来创建NSInvocation对象。因此我们必须重写这个方法，为给定的selector提供一个合适的方法签名。</strong></p>
<p>完整的示例如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div></pre></td><td class="code"><pre><div class="line">//-----------------------------------</div><div class="line">//SGH0511RuntimeMethod.h</div><div class="line"></div><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line"></div><div class="line">@interface SGH0511RuntimeMethod : NSObject</div><div class="line">+(instancetype)object;</div><div class="line">-(void)test;</div><div class="line">@end</div><div class="line"></div><div class="line">//-----------------------------------</div><div class="line">//SGH0511RuntimeMethod.m</div><div class="line"></div><div class="line">#import &quot;SGH0511RuntimeMethod.h&quot;</div><div class="line"></div><div class="line">@interface SGH0511RuntimeMethodHelper:NSObject</div><div class="line"></div><div class="line">-(void)method2;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation SGH0511RuntimeMethodHelper</div><div class="line"></div><div class="line">-(void)method2 &#123;</div><div class="line">    NSLog(@&quot;%@, %p&quot;, self, _cmd);</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">#pragma mark -</div><div class="line"></div><div class="line">@implementation SGH0511RuntimeMethod &#123;</div><div class="line">    SGH0511RuntimeMethodHelper *_helper;</div><div class="line">&#125;</div><div class="line">+(instancetype)object &#123;</div><div class="line">    return [[self alloc]init];</div><div class="line">&#125;</div><div class="line">- (instancetype)init</div><div class="line">&#123;</div><div class="line">    self = [super init];</div><div class="line">    if (self) &#123;</div><div class="line">        _helper = [[SGH0511RuntimeMethodHelper alloc]init];</div><div class="line">    &#125;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line"></div><div class="line">-(void)test &#123;</div><div class="line">    [self performSelector:@selector(method2)];</div><div class="line">&#125;</div><div class="line"></div><div class="line">-(NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123;</div><div class="line">    NSMethodSignature *signature = [super methodSignatureForSelector:aSelector];</div><div class="line">    if (!signature) &#123;</div><div class="line">        if ([SGH0511RuntimeMethodHelper instancesRespondToSelector:aSelector]) &#123;</div><div class="line">            signature = [SGH0511RuntimeMethodHelper instanceMethodSignatureForSelector:aSelector];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return signature;</div><div class="line">&#125;</div><div class="line"></div><div class="line">-(void)forwardInvocation:(NSInvocation *)anInvocation &#123;</div><div class="line">    if ([SGH0511RuntimeMethodHelper instancesRespondToSelector:anInvocation.selector]) &#123;</div><div class="line">        [anInvocation invokeWithTarget:_helper];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">//-----------------------------------</div><div class="line">//SGH0511Runtime3ViewController.m</div><div class="line"></div><div class="line">#import &quot;SGH0511Runtime3ViewController.h&quot;</div><div class="line">#import &quot;SGH0511RuntimeMethod.h&quot;</div><div class="line"></div><div class="line">@implementation SGH0511Runtime3ViewController</div><div class="line"></div><div class="line">- (void)viewDidLoad &#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    [[SGH0511RuntimeMethod object]test];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行后的打印：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">2017-05-12 14:00:20.975 ObjectiveCDemo160728[66561:2298632] &lt;SGH0511RuntimeMethodHelper: 0x600000005850&gt;, 0x10ca61e04</div></pre></td></tr></table></figure>
<p>NSObject的<code>forwardInvocation:</code>方法实现只是简单调用了<code>doesNotRecognizeSelector:</code>方法，它不会转发任何消息。这样，如果不在以上所述的三个步骤中处理未知消息，则会引发一个异常。</p>
<p>从某种意义上来讲，forwardInvocation:就像一个未知消息的分发中心，将这些未知的消息转发给其它对象。或者也可以像一个运输站一样将所有未知消息都发送给同一个接收对象。这取决于具体的实现。</p>
<h2 id="七、消息转发与多重继承"><a href="#七、消息转发与多重继承" class="headerlink" title="七、消息转发与多重继承"></a>七、消息转发与多重继承</h2><p>回过头来看第二和第三步，通过这两个方法我们可以允许一个对象与其它对象建立关系，以处理某些未知消息，而表面上看仍然是该对象在处理消息。<strong>通过这种关系，我们可以模拟“多重继承”的某些特性，让对象可以“继承”其它对象的特性来处理一些事情。</strong>不过，这两者间有一个重要的区别：<em>多重继承将不同的功能集成到一个对象中，它会让对象变得过大，涉及的东西过多；而消息转发将功能分解到独立的小的对象中，并通过某种方式将这些对象连接起来，并做相应的消息转发。</em></p>
<p>不过消息转发虽然类似于继承，但NSObject的一些方法还是能区分两者。如<code>respondsToSelector:</code>和<code>isKindOfClass:</code>只能用于继承体系，而不能用于转发链。便如果我们想让这种消息转发看起来像是继承，则可以重写这些方法，如以下代码所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">- (BOOL)respondsToSelector:(SEL)aSelector   &#123;</div><div class="line">    if ( [super respondsToSelector:aSelector] )</div><div class="line">        return YES;</div><div class="line">    else &#123;</div><div class="line">        /* Here, test whether the aSelector message can     </div><div class="line">         *            </div><div class="line">         * be forwarded to another object and whether that  </div><div class="line">         *            </div><div class="line">         * object can respond to it. Return YES if it can.  </div><div class="line">         */</div><div class="line">         //在这里，测试aSelector消息是否可以被转发到另一个对象，以及这个对象是否可以响应它。可以响应则返回YES。</div><div class="line">    &#125;</div><div class="line">    return NO;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>在此，我们已经<strong>了解了Runtime中消息发送和转发的基本机制。</strong>这也是Runtime的强大之处，通过它，我们可以为程序增加很多动态的行为，虽然我们在实际开发中很少直接使用这些机制(如直接调用<code>objc_msgSend</code>)，但了解它们有助于我们更多地去了解底层的实现。其实在实际的编码过程中，我们也可以灵活地使用这些机制，去实现一些特殊的功能，如hook操作等。</p>
  
	</div>
		<footer class="article-footer clearfix">
<div class="article-catetags">


</div>



	<div class="article-share" id="share">
	
	  <div data-url="https://univer2012.github.io/2017/05/11/8Objective-C-Runtime-Three/" data-title="读《Objective-C Runtime 运行时之三：方法与消息》摘录 | SengolnHuang&#39;s blog" data-tsina="2669931682" class="share clearfix">
	  </div>
	
	</div>


</footer>

   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2017/05/10/7_1Objective-C-Runtime-Two/" title="读《Objective-C Runtime 运行时之二：成员变量与属性》摘录">
  <strong>上一篇：</strong><br/>
  <span>
  读《Objective-C Runtime 运行时之二：成员变量与属性》摘录</span>
</a>
</div>


<div class="next">
<a href="/2017/05/11/9some-tips-in-development/"  title="开发中的一些小技巧(持续更新中)">
 <strong>下一篇：</strong><br/> 
 <span>开发中的一些小技巧(持续更新中)
</span>
</a>
</div>

</nav>

	

<section id="comments" class="comment">
  <div id="disqus_thread">
    <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  </div>
</section>

</div>  
      <div class="openaside"><a class="navbutton" href="#" title="Show Sidebar"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">Contents</strong>
 
 <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#基础数据类型"><span class="toc-number">1.</span> <span class="toc-text">基础数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#一、SEL"><span class="toc-number">1.1.</span> <span class="toc-text">一、SEL</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二、IMP"><span class="toc-number">1.2.</span> <span class="toc-text">二、IMP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三、Method"><span class="toc-number">1.3.</span> <span class="toc-text">三、Method</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#四、objc-method-description"><span class="toc-number">1.4.</span> <span class="toc-text">四、objc_method_description</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#方法相关操作函数"><span class="toc-number">2.</span> <span class="toc-text">方法相关操作函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#一、方法"><span class="toc-number">2.1.</span> <span class="toc-text">一、方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二、方法选择器"><span class="toc-number">2.2.</span> <span class="toc-text">二、方法选择器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三、方法调用流程"><span class="toc-number">2.3.</span> <span class="toc-text">三、方法调用流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#四、隐藏参数"><span class="toc-number">2.4.</span> <span class="toc-text">四、隐藏参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#五、获取方法地址"><span class="toc-number">2.5.</span> <span class="toc-text">五、获取方法地址</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#六、消息转发"><span class="toc-number">2.6.</span> <span class="toc-text">六、消息转发</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-动态方法解析"><span class="toc-number">2.6.0.1.</span> <span class="toc-text">1.动态方法解析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-备用接收者"><span class="toc-number">2.6.0.2.</span> <span class="toc-text">2.备用接收者</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-完整消息转发"><span class="toc-number">2.6.0.3.</span> <span class="toc-text">3.完整消息转发</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#七、消息转发与多重继承"><span class="toc-number">2.7.</span> <span class="toc-text">七、消息转发与多重继承</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#小结"><span class="toc-number">3.</span> <span class="toc-text">小结</span></a></li></ol>
 
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="Hide Sidebar"></a></div>
<aside class="clearfix">

  
<div class="github-card">
<p class="asidetitle">Github Card</p>
<div class="github-card" data-github="univer2012" data-width="220" data-height="119" data-theme="medium">
<script type="text/javascript" src="//cdn.jsdelivr.net/github-cards/latest/widget.js" ></script>
</div>
  </div>



  
<div class="categorieslist">
	<p class="asidetitle">Categories</p>
		<ul>
		
		  
			<li><a href="/categories/如何搭建个人博客/" title="如何搭建个人博客">如何搭建个人博客<sup>2</sup></a></li>
		  
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">Tags</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/thinkive/" title="thinkive">thinkive<sup>2</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">Links</p>
    <ul>
        
          <li>
            
            	<a href="https://coderq.com" target="_blank" title="一个面向程序员交流分享的新一代社区">码农圈</a>
            
          </li>
        
          <li>
            
            	<a href="http://wuchong.me" target="_blank" title="Jark&#39;s Blog">Jark&#39;s Blog</a>
            
          </li>
        
    </ul>
</div>

  


  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS</a>
</div>

  <div class="weiboshow">
  <p class="asidetitle">Weibo</p>
    <iframe width="100%" height="119" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=119&fansRow=2&ptype=1&speed=0&skin=9&isTitle=1&noborder=1&isWeibo=0&isFans=0&uid=2669931682&verifier=d0f169f2&dpc=1"></iframe>
</div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> Hello,我是黄胜军(@Univer-V)，一名来自中国深圳的iOS开发者。就职于思迪。 <br/>
			正在通往自由的路上。</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		<a href="http://weibo.com/2669931682" target="_blank" class="icon-weibo" title="微博"></a>
		
		
		<a href="https://github.com/univer2012" target="_blank" class="icon-github" title="github"></a>
		
		
		
		
		
		
		
		
		
		<a href="mailto:1054880335@qq.com" target="_blank" class="icon-email" title="Email Me"></a>
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2017 
		
		<a href="/about" target="_blank" title="黄胜军">黄胜军</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  c.click(function(){
    ta.css('display', 'block').addClass('fadeIn');
  });
  o.click(function(){
    ta.css('display', 'none');
  });
  $(window).scroll(function(){
    ta.css("top",Math.max(140,320-$(this).scrollTop()));
  });
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina'),
      description = $this.attr('description');
  var html = [
  '<div class="hoverqrcode clearfix"></div>',
  '<a class="overlay" id="qrcode"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="微信"></a>',
  '<a href="http://widget.renren.com/dialog/share?resourceUrl=' + encodedUrl + '&srcUrl=' + encodedUrl + '&title=' + title +'" class="article-share-renren" target="_blank" title="人人"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="微博"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);

  $('.hoverqrcode').hide();

  var myWidth = 0;
  function updatehoverqrcode(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
    var qrsize = myWidth > 1024 ? 200:100;
    var options = {render: 'image', size: qrsize, fill: '#2ca6cb', text: url, radius: 0.5, quiet: 1};
    var p = $('.article-share-qrcode').position();
    $('.hoverqrcode').empty().css('width', qrsize).css('height', qrsize)
                          .css('left', p.left-qrsize/2+20).css('top', p.top-qrsize-10)
                          .qrcode(options);
  };
  $(window).resize(function(){
    $('.hoverqrcode').hide();
  });
  $('.article-share-qrcode').click(function(){
    updatehoverqrcode();
    $('.hoverqrcode').toggle();
  });
  $('.article-share-qrcode').hover(function(){}, function(){
      $('.hoverqrcode').hide();
  });
});   
</script>




<script type="text/javascript">

var disqus_shortname = 'sengoln';

(function(){
  var dsq = document.createElement('script');
  dsq.type = 'text/javascript';
  dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
}());
(function(){
  var dsq = document.createElement('script');
  dsq.type = 'text/javascript';
  dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/count.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
}());
</script>






<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?62f484087b8a447efc5e7dbbc18aff7d";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="Back to Top"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
</html>
